Imagine we build an #erc20 like fungible token with the combination of #zksnark and #merkletree using this #algorithm described by 
Vitalik: https://vitalik.ca/general/2022/06/15/using_snarks.html

To execute a token transfer on this protocol, the user has to send a transaction to the token's #zk verifier contract. This transaction must 
be sent using the user's #eoa and #gas must be paid for.

Hence, with only #zeroknowledge, we can implement privacy only in terms of 'confidentiality' i.e. hiding information within the transaction; 
but not in terms of 'anonymity' i.e. hiding the addresses involved in 
the transaction.

True privacy = Confidentiality + Anonymity

There's a #cryptographic technique called 'Stealth Addresses' which can solve the problem of anonymity to some extent. Multiple versions and 
implementations of #stealthaddresses exist, most notably in #monero #blockchain.

So what is a #stealth address?

It's a one-time address generated by senders such that only the sender and receiver know that the address belongs to the receiver, but only 
the receiver can compute private key to that address.

⚙️ The receiver has two private/public key pairs: View Keypair (v, V) and Use Keypair (u, U), where V = v·G and U = u·G 
⚙️ The sender generates a temporary key pair (t, T) where T=t.G and reveals public key T publically
⚙️ Both sender and receiver can calculate a shared secret s using Elliptic Curve Diffie Hellman (#ecdh) protocol. Sender: s=hash(t.V) and 
Receiver: s=hash(T.v)
⚙️ Sender and Receiver both calculate stealth public key as s.G+U and generates a stealth address from it
⚙️ Receiver computes the private ket (s+u) which due to the way elliptic curves work is the private key of the above address
⚙️ The receiver can also share s and U with auditors to calculate stealth address to view transactions, but they cannot spend it because only 
the receiver knows u.

This protocol is not perfect. But add to it confidentiality using #zkp and we get nearly practically usable #privacy even on public chains.

Happy to respond to any questions in the comments.

Note: ECC public keys are generated by group multiplication of private key with a generator point G over a finite field, where + and . 
are elliptic curve group addition and multiplication. They are not the usual 2+3=5 and 2.3=6.
